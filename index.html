<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Three.js Hand Particles</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
    canvas { display: block; }
    #ui { position: absolute; bottom: 20px; width: 100%; text-align: center; color: white; pointer-events: none; }
    .btn { pointer-events: auto; padding: 10px 20px; background: rgba(255,255,255,0.2); border: 1px solid #fff; border-radius: 20px; color: white; margin: 5px; }
    video { display: none; } /* Hide the raw webcam feed */
  </style>
</head>
<body>
  <div id="ui">
    <div id="info">Hold up your hand to start!</div>
    <button class="btn" onclick="setShape('heart')">Heart</button>
    <button class="btn" onclick="setShape('sphere')">Sphere</button>
    <button class="btn" onclick="setShape('saturn')">Saturn</button>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    let currentShape = 'sphere';
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- Particle System Setup ---
    const count = 3000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const targetPositions = new Float32Array(count * 3);
    
    for(let i=0; i<count*3; i++) positions[i] = (Math.random()-0.5)*10;
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const material = new THREE.PointsMaterial({ size: 0.04, color: 0x00ffff, transparent: true, opacity: 0.8 });
    const points = new THREE.Points(geometry, material);
    scene.add(points);
    camera.position.z = 5;

    // --- Shape Logic ---
    function setShape(type) {
      currentShape = type;
      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        if (type === 'heart') {
          const t = Math.random() * Math.PI * 2;
          targetPositions[i3] = 0.15 * (16 * Math.pow(Math.sin(t), 3));
          targetPositions[i3+1] = 0.15 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
          targetPositions[i3+2] = (Math.random()-0.5) * 0.5;
        } else if (type === 'saturn') {
          if (i < count * 0.7) { // Sphere center
            const phi = Math.acos(-1 + (2 * i) / (count * 0.7));
            const theta = Math.sqrt(count * 0.7 * Math.PI) * phi;
            targetPositions[i3] = Math.cos(theta) * Math.sin(phi) * 1.5;
            targetPositions[i3+1] = Math.sin(theta) * Math.sin(phi) * 1.5;
            targetPositions[i3+2] = Math.cos(phi) * 1.5;
          } else { // Rings
            const r = 2.5 + Math.random() * 0.8;
            const a = Math.random() * Math.PI * 2;
            targetPositions[i3] = Math.cos(a) * r;
            targetPositions[i3+1] = (Math.random()-0.5) * 0.2; // Thin ring
            targetPositions[i3+2] = Math.sin(a) * r;
          }
        } else { // Sphere
          const phi = Math.acos(-1 + (2 * i) / count);
          const theta = Math.sqrt(count * Math.PI) * phi;
          targetPositions[i3] = Math.cos(theta) * Math.sin(phi) * 2;
          targetPositions[i3+1] = Math.sin(theta) * Math.sin(phi) * 2;
          targetPositions[i3+2] = Math.cos(phi) * 2;
        }
      }
    }
    setShape('sphere');

    // --- MediaPipe Mobile Config ---
    const videoElement = document.createElement('video');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 0, // 0 for faster performance on mobile
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    hands.onResults((results) => {
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmark = results.multiHandLandmarks[0][8]; // Index finger tip
        points.position.x = (0.5 - landmark.x) * 10;
        points.position.y = (0.5 - landmark.y) * 10;
        
        // Dynamic Color based on Height
        material.color.setHSL(landmark.y, 1, 0.5);
      }
    });

    const cameraUtils = new Camera(videoElement, {
      onFrame: async () => { await hands.send({image: videoElement}); },
      width: 640, height: 480
    });
    cameraUtils.start();

    function animate() {
      requestAnimationFrame(animate);
      const pos = geometry.attributes.position.array;
      for(let i=0; i<count*3; i++) {
        pos[i] += (targetPositions[i] - pos[i]) * 0.1; // Smooth morphing
      }
      geometry.attributes.position.needsUpdate = true;
      points.rotation.y += 0.01;
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
